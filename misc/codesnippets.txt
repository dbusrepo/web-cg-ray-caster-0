// load png as arraybuffer
// const imgUrl = (await import('../asset/images/samplePNGImage.png')).default;
// const imgBuffer = await loadUtils.loadResAsArrayBuffer(imgUrl);
// const pngDecoder = new PngDecoder24();
// const [w, h] = pngDecoder.readSize(imgBuffer);
// console.log(w, h);

// function calcImagesRegionSize(images: Assets.WasmImage[]): number {
//   const imagesIndexSize = Assets.WasmImage.OFFSET_SIZE * images.length;
//   const imagesHeaderDataSize = images.reduce(
//     (size, img) => (size += img.size),
//     0,
//   );
//   return imagesIndexSize + imagesHeaderDataSize;
// }

function getRegionsAlignSizes(
  sizes: Readonly<MemRegionsData>,
  memRegionsAllocSeq: MemRegionKeyType[],
): MemRegionsData {
  const alignSizes = {} as MemRegionsData;
  for (const region of memRegionsAllocSeq) {
    alignSizes[region] = sizes[region];
    if (sizes[region]) {
      const alignSize = MEM_REGIONS_ALIGN_SIZES[region] - 1;
      alignSizes[region] += alignSize;
    }
  }
  return alignSizes;
}


// const ASSETS_PATH = '../asset';
// const IMAGES_PATH = `${ASSETS_PATH}/images`;
// import myImgUrl from '../asset/images/samplePNGImage.png';

// function board_style(): object {
//   return {
//     // boxSizing: 'border-box',
//     // position: 'absolute',
//     width: config.display_width,
//     height: config.display_height,
//     // top: '-50px',
//     // width: '100%',
//     // height: '100%',
//     // objectFit: 'contain',
//     margin: 'auto',
//     // bottom: 0,
//     // left: 0,
//     // right: 0,
//     padding: 0,
//     border: '5px solid #c0c0c0',
//     // textAlign: 'center',
//   };
// }

// function canvas_style(): object {
//   return {
//     display: 'block',
//     // margin: 'auto',
//     // padding: 0,
//     // position: 'absolute',
//     // top: '-50px',
//     // bottom: 0,
//     // left: 0,
//     // right: 0,
//     // width: config.display_width,
//     // height: config.display_height,
//     width: '100%',
//     height: '100%',
//     // objectFit: 'fill',
//     imageRendering: 'pixelated',
//   };
// }

// Object.assign(this.container.style, board_style());

// this.board.tabIndex = 0; // call this before focus() !
// this.board.focus();
// this.board.addEventListener('keydown', (e) => {
//   console.log('board here');
//   // e.stopPropagation();
// });

// /**/
// // used to test mem all/gc, see memory-stats.js proj
// garbage: object[] = [];
// garbageSize = 1024 * 1024 * 6;
// garbageIdx = 0;

// // call GC() from console to test a GC
// private GC() {
//   this.garbage = [];
//   this.garbageIdx = 0;
// }

// private makeGarbage(amount: number) {
//   for (let i = 0; i < amount; i++) {
//     this.garbage[this.garbageIdx] = {};
//     this.garbageIdx = (this.garbageIdx + 1) % this.garbageSize;
//   }
// }
// use this.makeGarbage(1024); in render()
// /**/

private clearBckgr(): void {
    // js version
    // const frameUi32 = new Uint32Array(this._wasmData.ui8cFramebuffer.buffer);
    // const limit = this._pixelCount;
    // for (let i = 0; i !== limit; i += 1) {
    //   // canvas_mem[i] = 0xff_ff_00_00;
    //   frameUi32[i] = 0xff_00_00_00;
    // }

    // call asc function here! // TODO fix asc call here!
    // const frameBufferOffset = this._wasmData.memRegOffs[FRAME_BUF_IDX];
    // this._wasmData.ascExports.clearCanvasVec(frameBufferOffset);

    // this._ascFunctions.clearCanvasVec(this._canvasOffset);

    // canvas_mem[199 * 320 + 0] = 0xff_00_00_ff;

    // const canvas_mem: Uint32Array = new Uint32Array(this.canvas_mem_i8c.buffer);
    // const limit = this.pixel_count;
    // for (let i = 0; i !== limit; i += 4) {
    //   canvas_mem[i] = 0xff_00_00_00;
    //   canvas_mem[i + 1] = 0xff_00_00_00;
    //   canvas_mem[i + 2] = 0xff_00_00_00;
    //   canvas_mem[i + 3] = 0xff_00_00_00;
    // }

    // using ctx and not the imagedata, remove put_image_data in render()
    // const { ctx } = this;
    // ctx.fillStyle = 'blue';
    // ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    // ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    // const val = this.clear_wasm();
    // console.log(val);
  }

showStatsMenuCheckHandler(showStats: boolean) {
    this.getStats().isEnabled = showStats;
    this.engineWorker.postMessage({
command: 'sendsStats',
params: { value: showStats },
});
}

menuGui.ts:
// const guidiv = document.querySelectorAll('[class="dg main gui"]');
// const button = guidiv[0].querySelectorAll('.close-button');


  protected initConsole(): void {
    // note: console container is above the panel container and its canvas
    // focus given to console last has precedence
    this._isConsoleOpen = false;
    if (!this.panelSettings.enableConsole) {
      return;
    }
    this.initConsoleContainer();
    this.console = new Console(this.buildConsoleHandlers(), {
      hotkey: Panel.CONSOLE_KEY,
      welcome: 'Hello User.',
      caseSensitive: true,
      autoComplete: true,
      defaultHandler() {},
      container: this.consoleContainer,
      onShow: () => {
        // called immediately after key
        // this.remove_key_listener();
        this.onShowConsole();
      },
      onHide: () => {
        this.onHideConsole();
      },
      onClosing: () => {
        // before transitionEnd of the console...
        // show these immediately to avoid a pop effect of the menu gui/stats,
        // note: the console remains open and above 'cause it has higher zIndex
        this.onCloseConsole();
      },
    });
    this.container.addEventListener('focus', () => {
      // when closing the gui menu focus goes back to panel container ! so we
      // give focus also to the console's container
      // TODO check btw
      assert(this.consoleContainer);
      this.consoleContainer.focus();
    });
  }


this._canvasContainer.style.zIndex = String(
  Number(this._panel.style.zIndex) + 1,
);



let cc = 0;
setInterval(() => {
  cc++;
  this._stats!.update({
    // 'FPS': cc > 74 ? 50 : 30,
    'FPS': cc < 100 ? 200 + (Math.random() * 300) | 0 : Math.random()*50,
  });
}, 100);


private get_font_height(): number {
  return this._ctx.measureText('M').width + 1;
}

private draw_text(txt: string): void {
  // TODO x,y?
  this._ctx.font = 'bold 16pt monospace';
  const lineHeight = 3 + this.get_font_height();
  this._ctx.fillStyle = '#999'; // gray
  const lines = txt.split('\n');
  for (
      let i = 0, x = 1, y = lineHeight;
      i !== lines.length;
      i += 1, y += lineHeight
      ) {
    this._ctx.fillText(lines[i], x, y);
  }
}

private _sleepArr: Int32Array;
engine._sleepArr = new Int32Array(new SharedArrayBuffer(NUM_BYTES_DWORD)); // for atomic sleep

// worker main loop
for (;;) {
  syncWait(this._syncArr, idx, 0);
  // sleep(this._syncArr, idx, 1000);
  clearBg(this._wasmModules, color, this._frameHeightRange);
  syncStore(this._syncArr, idx, 0);
  syncNotify(this._syncArr, idx);
}


$(ASC_BUILD_DIR)/%.wasm: $(ASC_SOURCE_DIR)/%.ts build_flags $(ASC_CONFIG_FILE)
	@echo
	@echo Compiling $@ ...
	asc --config $(ASC_CONFIG_FILE) $< -o $@ -t $(basename $@).wat -b $(ASC_BINDINGS) --target $(TARGET)

	@echo $(MAKEFILE_LIST)


// function _new<T>(): T {
//   assert(isReference<T>());
//   const size = offsetof<T>();
//   // logi(addr);
//   const addr = alloc(size);
//   // logi(addr);
//   return changetype<T>(addr);
// }

// const v = _new<Vec>();
// logi(changetype<usize>(v));

// class Vec3 {
//     x: float;
//     y: float;
//     z: float;
//     // w: float;
//     // position, also color (r,g,b)
//     // constructor(public x: float = 0.0, public y: float = 0.0, public z: float = 0.0) {}
//     init(x: float, y: float, z: float): void {
//       this.x = x;
//       this.y = y;
//       this.z = z;
//     }

//     static new(x: float, y: float, z: float): Vec3 {
//       const size = offsetof<Vec3>();
//       const f: usize = alloc(size);
//       const p = changetype<Vec3>(f);
//       p.x = x; p.y = y; p.z = z;
//       return p;
//     }

//     static delete(v: Vec3): void {
//       const ptr = changetype<usize>(v);
//       dealloc(ptr);
//     }
// }

// @global function __new(size: usize, id: u32): usize {
//   logi(<i32>size);
//   return 0;
// }

// export function instantiateRaw<T>(): T {
//     // when field is class with nonnull, it's unsafe.
//     if (isReference<T>()) {
//         return changetype<T>(__new(offsetof<T>(), idof<T>()));
//     }
//     // It's safe.
//     return instantiate<T>();
// }

function printValues(): void {

  // const myArr = new StaticArray<i32>(100);
  // logi(memory.grow(1));

  // logi(<i32>heap.alloc(16));
  // logi(sleepArr);
  
  // NativeMathf.seed

  // logi(syncLoc);

  // logi(ASC_MEMORY_BASE);
  // const myblock = heap.alloc(16);
  // logi(memory.size()); //<<16);
  logi(i32(__data_end));
  logi(<i32>__heap_base);
  // logi(<i32>myblock);
  // log(heap.alloc(10));
}

// const workerAlloc = await loadWasm<typeof workerHeapAllocExport>(
//   'workerHeapAlloc',
//   workerHeapAllocWasm,
//   wasmInit,
// );
const engineWorker = await loadWasm<typeof engineWorkerExport>(
  'engineWorker',
  engineWorkerWasm,
  wasmInit,
  // workerAlloc,
);

function testVec3(): Vec3 {
  // const f: usize = alloc(16);
  // const p = changetype<Vec3>(f);
  // p.init(3, 4, 5);
  // return p;
  // return Vec3.new(3, 4, 5);
  const v = newVec3(3, 4, 5);
  // v.init(7,2,3);
  return v;
}

  const v = testVec3();
  logi(changetype<usize>(v));
  // logf(v.x);

  // Vec3.delete(v);

  // logi(s);
  // logi(e);
  // logi(heapOffset);
  // logi(workerHeapSize);
  // logi(heapLoc);
  // logi(__heap_base);
  // logi(alloc(10));
  // logi(alloc(12));
  // logi(alloc(1024));
  // logi(alloc(1024));
  // const addr = alloc(4);
  // logi(load<u32>(addr));
  // logi(alloc(1));
  // printValues();

  // const f: usize = alloc(12);
  // // const g: usize = alloc(2);
  // // const h: usize = alloc(3);
  // logi(f);

  // const g: usize = alloc(5);
  // logi(g);
  // dealloc(f);
  // // dealloc(g);

  // const h: usize = alloc(7);
  // logi(h);

  // logi(-1);
  // dealloc(h);
  // logi(-1);
  // dealloc(g);
  // logi(-1);
  // const z: usize = alloc(2);
  // logi(z);
  // logi(-1);

    // if (workerIdx > 0) {
    //   // const a = alloc(256);
    // }

  while (true) {
    // const f: usize = alloc(12);
    // // const g: usize = alloc(2);
    // // const h: usize = alloc(3);
    // logi(f);
    // // logi(g);
    // // logi(h);
    // const g: usize = alloc(5);
    // logi(g);
    // dealloc(f);
    // dealloc(g);

    // const v = newVec3(c, c+1, c+2);
    // c+=3;
    // delVec3(v);

    // const h: usize = alloc(7);
    // dealloc(h);
    // logi(h);

    // const a = alloc(77);
    // if (workerIdx <= 0) {
    // const a = alloc(12);
    // }
    atomic.wait<i32>(syncLoc, 0);
    clearBg(bgColor, s, e);
    atomic.store<i32>(syncLoc, 0);
    atomic.notify(syncLoc);
    break;
  }


# ifeq (build_asc,$(findstring build_asc,$(MAKECMDGOALS)))
ifneq "" "$(or $(findstring build_asc,$(MAKECMDGOALS)), $(findstring all,$(MAKECMDGOALS)))"

ifeq (,$(findstring clean,$(MAKECMDGOALS)))


private async initEngineWorkers(wasmMemStartSize: number): Promise<void> {
  assert(Engine.NUM_WORKERS >= 1);

  this._workers = [];

  let count = Engine.NUM_WORKERS;
  const now = Date.now();

  return new Promise((resolve, reject) => {
    for (
      let workerIdx = 0;
      workerIdx < Engine.NUM_WORKERS;
      ++workerIdx
    ) {
      const worker = new Worker(
        new URL('./engineWorker.ts', import.meta.url),
        {
          name: `worker-${workerIdx}`,
          type: 'module',
        },
      );
      this._workers.push(worker);
      worker.onmessage = ({ data: msg }) => {
        // TODO
        console.log(
          `Worker ready: id=${workerIdx}, count=${--count}, time=${
            Date.now() - now
          }ms`,
        );
        if (count === 0) {
          console.log(`All workers ready. After ${Date.now() - now}ms`);
          resolve();
        }
      };
      worker.onerror = (error) => {
        console.log(`Worker id=${workerIdx} error: ${error.message}\n`);
        reject(error);
      };
      const workerConfig = this.buildWorkerConfig(
        workerIdx,
        wasmMemStartSize,
      );
      worker.postMessage({
        command: 'init',
        params: workerConfig,
      });
    }
  });
}

&& npm run onchange:wasm

"onchange:wasm": "onchange -v -i 'src/engine/wasm/makefile' 'src/engine/wasm/asconfig.json' 'src/engine/wasm/src/**/*.ts' -- make --no-print-directory --debug=basic -C src/engine/wasm ",

let arr = newVector<u32>(2);
logi(arr.length);
logi(arr.start);
logi(arr.end);
// // logi(arr.end);
logi(changetype<usize>(arr.atIdx(0)));
logi(changetype<usize>(arr.atIdx(1)));
// deleteVector(arr);

from darray:

// @inline get objSize(): SIZE_T {
//   return this._objSize;
// }

// @inline get start(): PTR_T {
//   return this._data;
// }

// @inline get end(): PTR_T {
//   return this._next;
// }

// @inline get length(): u32 {
//   return this._count;
// }

// @inline get arrayStart(): PTR_T {
//   return this._array;
// }

// @inline get arrayEnd(): PTR_T {
//   return this._arrayEnd;
// }


// const imagesDir = '../assets/images/';
// const fileNames = Object.values(imagesList);
// console.log(`PATH: ${imagesDir}${fileNames[0]}`);
// // const imagesUrls = await Promise.all(
// //   Object.values(imagesList).map(
// //     async (fileName) => (await import(`${imagesDir}${fileName}`)).default,
// //   ),
// // );
// // this._imagesPaths = imagesUrls;
// // console.log(imagesUrls);
// const path = 'samplePNGImage.png';
// const imgUrl = (await import('../assets/images/samplePNGImage.png')).default;
// const imgUrl2 = (await import('../assets/images/samplePNGImage2.png')).default;
// this._imagesPaths = [imgUrl, imgUrl2];

// const imagesDir = '../assets/images/';
// const imagesUrls = await Promise.all(
//   Object.values(imagesList).map(
//     async (fileName) => console.log(fileName),
//   ),
// );

while (true) {
  atomic.wait<i32>(syncLoc, 0);
  // const v = vec3Alloc.new();
  // clearBg(bgColor, s, e);

  // // logi(image.height);
  if (workerIdx == 1) {
    for (let i = s; i != e; ++i) {
      let screenPtr: PTR_T = frameBufferPtr + i * frameWidth * 4;
      const pixels: PTR_T = image.pixels + i * image.width * 4;
      memory.copy(screenPtr, pixels, frameWidth * 4);
    }
  }

  if (workerIdx == 0) {
    draw.drawText(strings.SENT2, 10, 10, 1, 0xFF_00_00_FF);
    draw.drawText(strings.SENT2, 10, 18, 2, 0xFF_00_00_FF);
    // let y = 20;
    // for (let s = 1; s < 5; ) {
    //   draw.drawText(strings.SENT2, 10, y, f32(s), 0xFF_00_00_FF);
    //   y += FONT_Y_SIZE * s;
    //   s++;
    // }
  }

  atomic.store<i32>(syncLoc, 0);
  atomic.notify(syncLoc);
}

function run(): void {

  initWorkerMem();

  // const p = alloc(32);
  // const t = alloc(32);
  // dealloc(p);
  // logi(load<u32>(WORKER_MEM_COUNTER_PTR));

  // logi(strings.MSG1);
  // logi(strings.SENT2);
  // logi(strings.SENT3);

  // logi(load<u8>(fontCharsPtr + 65*8));

  // logi(load<u8>(stringsDataPtr));
  // logi(load<u8>(stringsDataPtr+1));
  // logi(load<u8>(stringsDataPtr+2));
  // logi(load<u8>(stringsDataPtr+3));
  // logi(load<u8>(stringsDataPtr+4));

  // logi(stringsIndexPtr);
  // logi(stringsIndexSize);
  // logi(stringsDataPtr);
  // logi(stringsDataSize);

  // logi(fontCharsPtr);
  // logi(fontCharsSize);

  // logi(usePalette);
  // logi(imagesIndexPtr);
  // logi(imagesIndexSize);
  // logi(imagesDataPtr);
  // logi(imagesDataSize);
  // logi(numImages);

  // logi(MYIMG);
  // logi(imagesIndexSize);

  // test();
  // test images loading
  // logi(numImages);
  // const images = initImages();
  // for (let i = 0; i < images.length(); ++i) {
  //   const pixels = images.at(i).pixels;
  //   logi(<i32>pixels);
  //   const byte = load<u8>(pixels);
  //   logi(byte);
  //   logi(images.at(i).width);
  //   logi(images.at(i).height);
  // }

  const images = initImages();
  const image = images.at(0);

  // const width = image.width;
  // const height = image.height;

  // let screenPtr: PTR_T;
  // let pixels: PTR_T;

  // logi(imagesIndexOffset);
  // logi(image.pixels);
  // logi(image.width);
  // logi(image.height);
  // for (let i = 0; i != frameHeight; ++i) {
  //   let screenPtr: PTR_T = frameBufferPtr + i * frameWidth * 4;
  //   const pixels: PTR_T = image.pixels + i * image.width * 4;
  //   memory.copy(screenPtr, pixels, frameWidth * 4);

  //   // screenPtr = frameBufferPtr + i * frameWidth * 4;
  //   // pixels = image.pixels + i * image.width * 4;
  //   // // logi(screenPtr);
  //   // for (let j = 0; j != frameWidth; ++j) {
  //   //   const col = load<u32>(pixels);
  //   //   store<u32>(screenPtr, col);
  //   //   // store<i32>(screenPtr, 0xFF_00_00_FF);
  //   //   pixels += 4;
  //   //   screenPtr += 4;
  //   //   // logi(j);
  //   // }
  // }

  const r = utils.range(workerIdx, numWorkers, frameHeight);
  const s = <u32>(r >> 32);
  const e = <u32>r;

  // logi(<i32>process.hrtime())

  // logi(sleepLoc);
  // logi(load<u32>(sleepLoc));

  while (true) {
    atomic.wait<i32>(syncLoc, 0);
    // utils.sleep(sleepLoc, 16);

    // draw.clearBg(s, e, 0xff_00_00_00); // ABGR
    draw.clearBg(s, e, bgColor); // ABGR
    // logi(0);


    // // // logi(image.height);
    // if (workerIdx == 1) {
    //   for (let i = s; i != e; ++i) {
    //     let screenPtr: PTR_T = frameBufferPtr + i * frameWidth * 4;
    //     const pixels: PTR_T = image.pixels + i * image.width * 4;
    //     memory.copy(screenPtr, pixels, frameWidth * 4);
    //   }
    // }

    // if (workerIdx == 0) {
    //   draw.drawText(strings.SENT2, 10, 10, 1, 0xFF_00_00_FF);
    //   draw.drawText(strings.SENT2, 10, 18, 2, 0xFF_00_00_FF);
    //   // let y = 20;
    //   // for (let s = 1; s < 5; ) {
    //   //   draw.drawText(strings.SENT2, 10, y, f32(s), 0xFF_00_00_FF);
    //   //   y += FONT_Y_SIZE * s;
    //   //   s++;
    //   // }
    // }

    // logi(load<u8>(inputKeysPtr));

    atomic.store<i32>(syncLoc, 0);
    atomic.notify(syncLoc);
  }

}


logi(nextPowerOfTwo(8));

// const log = (msgNum: number, strIdx: number) => {
// console.log('str idx is ' + strIdx);
// const lenIdx = strIdx - 4;
// const len = new Uint32Array(this._memory.buffer, lenIdx, 4)[0];
// console.log('Lenght is ' + len);
// const strBytesSrc = new Uint16Array(this._memory.buffer, strIdx, len);
// const strBytes = strBytesSrc.slice();
// const str = new TextDecoder('utf-16').decode(strBytes);
// console.log('The string is ' + str);
// const msg = clearCanvasModule.instance.exports.__getString(msgIdx);
// console.log(`Message: ${msgNum} ${msg}`);
// };

// const importObject = {
//   env: {
//     buffer: memory,
//     canvas_width: w, // TODO fix names?
//     canvas_height: h,
//     pixkl_count,
//     log: (msgIdx: number, msg: string) => {
//       console.log(`Message: ${msgIdx} ${msg}`)
//     }
//   },
// };

if (side === 0) {
  let r = (color & 0xff0000) >> 16;
  let g = (color & 0x00ff00) >> 8;
  let b = (color & 0x0000ff) >> 0;
  r = (r * 3) >> 2;
  g = (g * 3) >> 2;
  b = (b * 3) >> 2;
  // r >>>= 1;
  // g >>>= 1;
  // b >>>= 1;
  color = (0xff << 24) | (r << 16) | (g << 8) | (b << 0);
}

write color value expr in abgr format (or use the make color function from a
rgba value): so abgr exp format -> write them to wasm memory -> little endian
swap when storing and then when loading -> abgr again (when values are read for
drawing by the impl it seems the colo bytes values should be in abgr format)

note texels fron png are already written in rgba format so when they are loaded
(bytes are swapped little endian) they are in abgr format


// @ts-ignore: decorator
@inline function align<T>(): SIZE_T {
  return alignof<T>();
}

// const sliceHeight = wallBottom - wallTop;
// if (sliceHeight < vpHeight) {
  // floor visible
  // if (side === 0 && rayDirX > 0) {
  //   floorWallX = rayMapX + 1.0;
  //   floorWallY = rayMapY + wallX;
  // } else if (side === 0 && rayDirX < 0) {
  //   floorWallX = rayMapX;
  //   floorWallY = rayMapY + wallX;
  // } else if (side === 1 && rayDirY > 0) {
  //   floorWallX = rayMapX + wallX;
  //   floorWallY = rayMapY + 1.0;
  // } else {
  //   floorWallX = rayMapX + wallX;
  //   floorWallY = rayMapY;
  // }
  //
  // wallSlice.floorWallX = floorWallX;
  // wallSlice.floorWallY = floorWallY;
// }

// asc
// function run(): void {
//   // initWorkerMem();
//
//   // const p = alloc(32);
//   // const t = alloc(32);
//   // dealloc(p);
//   // logi(load<u32>(WORKER_MEM_COUNTER_PTR));
//
//   // logi(strings.MSG1);
//   // logi(strings.SENT2);
//   // logi(strings.SENT3);
//
//   // logi(load<u8>(fontCharsPtr + 65*8));
//
//   // logi(load<u8>(stringsDataPtr));
//   // logi(load<u8>(stringsDataPtr+1));
//   // logi(load<u8>(stringsDataPtr+2));
//   // logi(load<u8>(stringsDataPtr+3));
//   // logi(load<u8>(stringsDataPtr+4));
//
//   // logi(stringsIndexPtr);
//   // logi(stringsIndexSize);
//   // logi(stringsDataPtr);
//   // logi(stringsDataSize);
//
//   // logi(fontCharsPtr);
//   // logi(fontCharsSize);
//
//   // logi(MYIMG);
//
//   // test();
//   // test images loading
//   // const images = initImages();
//   // for (let i = 0; i < images.length(); ++i) {
//   //   const pixels = images.at(i).pixels;
//   //   logi(<i32>pixels);
//   //   const byte = load<u8>(pixels);
//   //   logi(byte);
//   //   logi(images.at(i).width);
//   //   logi(images.at(i).height);
//   // }
//
//   const images = initImages();
//   const image = images.at(0);
//
//   // const width = image.width;
//   // const height = image.height;
//
//   // let screenPtr: PTR_T;
//   // let pixels: PTR_T;
//
//   // logi(imagesIndexOffset);
//   // logi(image.pixels);
//   // logi(image.width);
//   // logi(image.height);
//   // for (let i = 0; i != frameHeight; ++i) {
//   //   let screenPtr: PTR_T = frameBufferPtr + i * frameWidth * 4;
//   //   const pixels: PTR_T = image.pixels + i * image.width * 4;
//   //   memory.copy(screenPtr, pixels, frameWidth * 4);
//
//   //   // screenPtr = frameBufferPtr + i * frameWidth * 4;
//   //   // pixels = image.pixels + i * image.width * 4;
//   //   // // logi(screenPtr);
//   //   // for (let j = 0; j != frameWidth; ++j) {
//   //   //   const col = load<u32>(pixels);
//   //   //   store<u32>(screenPtr, col);
//   //   //   // store<i32>(screenPtr, 0xFF_00_00_FF);
//   //   //   pixels += 4;
//   //   //   screenPtr += 4;
//   //   //   // logi(j);
//   //   // }
//   // }
//
//   const r = utils.range(workerIdx, numWorkers, frameHeight);
//   const s = <u32>(r >> 32);
//   const e = <u32>r;
//
//   // logi(<i32>process.hrtime())
//
//   // logi(sleepLoc);
//   // logi(load<u32>(sleepLoc));
//
//   draw.clearBg(s, e, 0xff_00_00_00); // ABGR
// }

// function drawQuad(x: i32, y: i32, w: i32, h: i32, colorARGB: u32): void {
//   for (let i = 0; i < h; ++i) {
//     const rowPtr = rgbaSurface0ptr + (y + i) * rgbaSurface0width * BPP_RGBA
//     for (let j = 0; j < w; ++j) {
//       const screenPtr = rowPtr + (x + j) * BPP_RGBA;
//       store<u32>(screenPtr, colorARGB);
//     }
//   }
// }

function render(): void {

  // utils.sleep(sleepLoc, 1);

  const r = utils.range(workerIdx, numWorkers, rgbaSurface0height);
  const s = <usize>(r >> 32);
  const e = <usize>r;
  // logi(r as i32);

  // const t0 = <u64>process.hrtime();

  draw.clearBg(s, e, 0xff_00_00_00); // ABGR

  // if (workerIdx == MAIN_THREAD_IDX) {
  //   const color1 = FrameColorRGBA.colorABGR(0xff, 0, 0, 0xff);
  //   for (let l = 0; l < MAX_LIGHT_LEVELS; ++l) {
  //     const color2 = frameColorRGBA.lightColorABGR(color1, l);
  //     // const color2 = frameColorRGBA.fogColorABGR(color1, l);
  //     drawQuad(0, l * 2, 100, 2, color2);
  //   }
  // }


  // logi(c++);
  // heapAlloc(1024*1024);

  // const t1 = <u64>process.hrtime();
  // store<u64>(hrTimerPtr, t1 - t0);

  // render mipmaps test
  // if (workerIdx == MAIN_THREAD_IDX) {
  //   // const mipmap = textures.at(GREYSTONE).getMipmap(0);
  //   const numMipmaps = textures.at(GREYSTONE).NumMipmaps;
  //   // draw all mipmap levels
  //   const scaleX = 3;
  //   const scaleY = 3;
  //   let scrX: SIZE_T = 0;
  //   for (let i: SIZE_T = 0; i < numMipmaps; ++i) {
  //     const mipmap = textures.at(GREYSTONE).getMipmap(i);
  //     let srcPtr: PTR_T = mipmap.Ptr;
  //     let dstPtr: PTR_T = rgbaSurface0ptr + scrX * 4;
  //     myAssert(mipmap.Height * scaleY <= rgbaSurface0height);
  //     myAssert(mipmap.Width * scaleX <= rgbaSurface0width);
  //     for (let i: SIZE_T = 0; i != mipmap.Height; ++i) {
  //       for (let sy: SIZE_T = 0; sy != scaleY; ++sy) {
  //         // memory.copy(dstPtr, srcPtr, mipmap.Width * 4);
  //         let dstRowPtr = dstPtr;
  //         let srcRowPtr = srcPtr;
  //         for (let j: SIZE_T = 0; j != mipmap.Width; ++j) {
  //           const srcPixel = load<u32>(srcRowPtr);
  //           for (let sx: SIZE_T = 0; sx != scaleX; ++sx) {
  //             store<u32>(dstRowPtr, srcPixel);
  //             dstRowPtr += 4;
  //           }
  //           srcRowPtr += 4;
  //         }
  //         dstPtr += rgbaSurface0width * 4;
  //       }
  //       srcPtr += mipmap.Width * 4;
  //     }
  //     // adjust scrX for the next mipmap level
  //     scrX += mipmap.Width * scaleX;
  //   }
  // }

  // if (workerIdx == MAIN_THREAD_IDX) {
    // draw.drawText(strings.SENT2, 10, 10, 1, 0xFF_00_00_FF);
    // draw.drawText(strings.SENT2, 10, 18, 2, 0xFF_00_00_FF);
    // let y = 20;
    // for (let s = 1; s < 5; ) {
    //   draw.drawText(strings.SENT2, 10, y, f32(s), 0xFF_00_00_FF);
    //   y += FONT_Y_SIZE * s;
    //   s++;
    // }
  // }

  // logi(load<u8>(inputKeysPtr));

  // logi(align<u64>());
  // logi(hrTimerPtr);
  // const t0 = <u64>process.hrtime();
  // draw.clearBg(0, frameHeight, 0xff_00_00_00);
  // const t1 = <u64>process.hrtime();
  // store<u64>(hrTimerPtr, t1 - t0);
}

// if (
//   !(
//     pointerLockDeactivatedAt === null ||
//     performance.now() - pointerLockDeactivatedAt > 1300
//   )
// ) {
//   console.log('too early...');
//   return;
// }

// assert(floorXidx >= 0 && floorXidx < mapWidth, `floorXidx: ${floorXidx}, floorX: ${floorX}, weight: ${weight}, floorWallX: ${floorWallX}, posX: ${posX}`);
// const floorXidx = floorX | 0;
// const floorYidx = floorY | 0;
// if (
//   floorXidx < 0 ||
//   floorXidx >= mapWidth ||
//   floorYidx < 0 ||
//   floorYidx >= mapHeight
// ) {
//   continue;
// }
// const floorTexMapIdx = floorYidx * mapWidth + floorXidx;
// assert(floorTexMapIdx >= 0 && floorTexMapIdx < floorTexturesMap.length);

// mipPixels.vi
// const texels = new Uint32Array(
//   mipPixels.buffer,
//   mipPixels.byteOffset + mipRowOffs * 4,
//   mipPixels.byteLength / 4,
// );
// const texels = mipPixels.subarray(mipRowOffs, mipRowOffs + 64);

// assert(
//   floorTexMapIdx >= 0 && floorTexMapIdx < floorTexturesMap.length,
//   `floorX: ${floorX} floorY: ${floorY} x1: ${x1} x2: ${x2} y: ${y}`,
//   // `flooorX: ${floorX} floorY: ${floorY}`,
//   // `floorTexMapIdx: ${floorTexMapIdx} floorXidx: ${floorXidx} floorYidx: ${floorYidx}
//   //  flooorX: ${floorX} floorY: ${floorY}`,
// );

// // from render.ts
// let framePtr;
//
// // render horz line at minWallTop
// framePtr = startFramePtr + minWallTop * frameStride;
// for (let x = colStart; x < colEnd; x++) {
//   frameBuf32[framePtr++] = 0xff00ff00;
// }
//
// // render horz line at maxWallTop
// framePtr = startFramePtr + maxWallTop * frameStride;
// for (let x = colStart; x < colEnd; x++) {
//   frameBuf32[framePtr++] = 0xff00ff00;
// }
//
// // render horz line at minWallBottom
// framePtr = startFramePtr + minWallBottom * frameStride;
// for (let x = colStart; x < colEnd; x++) {
//   frameBuf32[framePtr++] = 0xffffff00;
// }
//
// // render horz line at maxWallBottom
// framePtr = startFramePtr + maxWallBottom * frameStride;
// for (let x = colStart; x < colEnd; x++) {
//   frameBuf32[framePtr++] = 0xffffff00;
// }

// render ceil/floor between walls
// framePtr = startFrameViewPtr + minWallTop * frameStride;

// for (let y = minWallTop; y < viewMidY; y++) {
//   for (let x = colStart; x < colEnd; x++) {
//     const wallSlice = wallSlices[x];
//     if (!(y >= wallSlice.Top && y <= wallSlice.Bottom)) {
//       // const mipRowOffs = wallSlice.TexX << wallSlice.CachedMipmap.PitchLg2;
//       // const texColOffs = wallSlice.TexPosY | 0;
//       // wallSlices[x].TexPosY = wallSlice.TexPosY + wallSlice.TexStepY;
//       // color = wallSlice.CachedMipmap.Buf32[mipRowOffs | texColOffs];
//       // color = mipmap.Buf32[(texX << mipmap.PitchLg2) | (texPosY | 0)];
//       frameBuf32[framePtr + x] = CEIL_COLOR;
//     }
//   }
//   framePtr += frameStride;
// }

// for (let y = viewMidY + 1; y <= maxWallBottom; y++) {
//   for (let x = colStart; x < colEnd; x++) {
//     const wallSlice = wallSlices[x];
//     if (!(y >= wallSlice.Top && y <= wallSlice.Bottom)) {
//       frameBuf32[framePtr + x] = FLOOR_COLOR;
//     }
//   }
//   framePtr += frameStride;
// }

// render floor below walls
// framePtr = startFrameViewPtr + (maxWallBottom + 1) * frameStride + colStart;
//
// for (let y = maxWallBottom + 1; y < viewHeight; y++) {
//   const yd = y - viewMidY;
//   const sDist = posZ / yd;
//   const stepX = sDist * (rayDirRightX - rayDirLeftX) * invWidth;
//   const stepY = sDist * (rayDirRightY - rayDirLeftY) * invWidth;
//   let floorX = posX + sDist * rayDirLeftX;
//   let floorY = posY + sDist * rayDirLeftY;
//   for (let x = colStart; x < colEnd; x++) {
//     const floorXidx = floorX | 0;
//     const floorYidx = floorY | 0;
//     const floorTexMapIdx = floorYidx * mapWidth + floorXidx;
//     if (floorTexMapIdx >= 0 && floorTexMapIdx < floorTexturesMap.length) {
//       const tex = floorTexturesMap[floorTexMapIdx].getMipmap(0);
//       const u = floorX - floorXidx;
//       const v = floorY - floorYidx;
//       // assert(floorX >= 0 && floorX < 1);
//       // assert(floorY >= 0 && floorY < 1);
//       const floorTexX = (u * tex.Width) | 0;
//       const floorTexY = (v * tex.Height) | 0;
//       const texOffs = (floorTexX << tex.PitchLg2) | floorTexY;
//       // assert(texOffs >= 0 && texOffs < floorTex.Buf32.length);
//       const color = tex.Buf32[texOffs];
//       // console.log(texOffs);
//       // console.log('color: ', color);
//       frameBuf32[framePtr] = color;
//     }
//     framePtr++;
//     floorX += stepX;
//     floorY += stepY;
//   }
//   framePtr += frameStride - viewWidth;
// }

// mipmap is rotated 90ccw
// const mipStride = 1 << pitchLg2;
const mipRowOffs = texX << lg2Pitch;
let offs = mipRowOffs + texY;
// // wall alg2: dda
for (; framePtr < frameLimitPtr; framePtr += frameStride) {
  // const texColOffs = texY | 0;
  // const color = mipPixels[mipRowOffs + texColOffs];
  const color = mipPixels[offs | 0];
  // const color = texels[texColOffs];
  // const color = mipmap.Buf32[texY * texWidth + texX];
  // color = frameColorRGBAWasm.lightColorABGR(color, 255);
  frameBuf32[framePtr] = color;
  // frameColorRGBAWasm.lightPixel(frameBuf32, dstPtr, 120);
  // texY += texStepY;
  offs += texStepY;
  // framePtr += frameStride;
}

// TODO: horz floor casting gives out bounds with rayDirX. check
// const cameraX = (2 * x) / (vpWidth - 1) - 1;

// wallX -= Math.floor(wallX);
// wallX %= 1;
// wallX -= wallX | 0;

const u32Val = new Uint32Array(1);

u32Val[0] = curMapPos[side] + step[side];
if (u32Val[0] >= mapLimits[side]) {
  outOfMap = true;
  break;
}
const nextPos = u32Val[0];

do {
  if (sideDistX < sideDistY) {
    side = 0;
    perpWallDist = sideDistX;
    checkWallIdx = xMapOffs + xChkIdx;
    if (xMap[checkWallIdx]) {
      break;
    }
    nextMapX = curMapX + stepX;
    if (nextMapX < 0 || nextMapX >= mapWidth) {
      outOfMap = true;
      break;
    }
    curMapX = nextMapX;
    sideDistX += deltaDistX;
    xMapOffs += stepX;
    yMapOffs += stepX;
  } else {
    side = 1;
    perpWallDist = sideDistY;
    checkWallIdx = yMapOffs + yChkOff;
    if (yMap[checkWallIdx]) {
      break;
    }
    nextMapY = curMapY + stepY;
    if (nextMapY < 0 || nextMapY >= mapHeight) {
      outOfMap = true;
      break;
    }
    curMapY = nextMapY;
    sideDistY += deltaDistY;
    yMapOffs += yStepYOffs;
    xMapOffs += xStepYOffs;
  }
} while (--MAX_STEPS);

if (this.renderer.TexturedFloor && this.renderer.VertFloor) {
  if (side === 0) {
    floorWallY = this.curMapPos[1] + wallX;
    floorWallX = this.curMapPos[0] + this.checkWallIdxOffs[0];
  } else {
    floorWallX = this.curMapPos[0] + wallX;
    floorWallY =
      this.curMapPos[1] + this.checkWallIdxOffs[1] / this.yWallMapWidth;
  }
  wallSlice.FloorWallX = floorWallX;
  wallSlice.FloorWallY = floorWallY;
}

// const cameraX = 2 * (width - 1) / width - 1;
// (2 * width - 2) / width - 1;
// 2 - 2 / width - 1 = 1 - 2 / width
// 2 * x / (width - 1) - 1, 
// => x = width - 1, 2 * (width - 1) / (width - 1) - 1 = 1, x = 0, 2 * 0 / (width - 1) - 1 = -1
// console.log(cameraX);
private syncWorkers() {
  for (let i = 0; i < this.auxWorkers.length; ++i) {
    const { index: workerIdx } = this.auxWorkers[i];
    Atomics.store(this.syncArray, workerIdx, 1);
    Atomics.notify(this.syncArray, workerIdx);
  }
  // this.wasmEngine.syncWorkers(this.auxWorkers);
}

private waitWorkers() {
  for (let i = 0; i < this.auxWorkers.length; ++i) {
    const { index: workerIdx } = this.auxWorkers[i];
    Atomics.wait(this.syncArray, workerIdx, 1);
  }
  // this.wasmEngine.waitWorkers(this.auxWorkers);
}

console.log('Num of transp walls slices: ', this.numTranspSlices);
for (let x = 0; x < vpWidth; x++) {
  let numWallSlicesCol = 0;
  let slicePtr = this.transpSlices[x];
  if (slicePtr !== WASM_NULL_PTR) {
    do {
      numWallSlicesCol++;
      slicePtr = slicePtr.Next as Slice; // double linked list here
    } while (slicePtr !== this.transpSlices[x]);
  }
  console.log(`x: ${x}, numWallSlicesCol: ${numWallSlicesCol}`);
}

// if (this.useWasm) {
//   this.wasmEngineModule.render();
// } else {

private renderViewFullVert() {
  const {
    startFramePtr,
    frameBuf32,
    frameStride,
    frameRowPtrs,
    isFloorTextured,
    raycaster,
    textures,
  } = this;

  const {
    FloorMap: floorMap,
    WallSlices: wallSlices,
    MapWidth: mapWidth,
    ProjYCenter: projYCenter,
  } = raycaster;

  const {
    // StartX: vpStartX,
    // StartY: vpStartY,
    Width: vpWidth,
    Height: vpHeight,
  } = raycaster.Viewport;

  const { PosX: posX, PosY: posY, PosZ: posZ } = raycaster.Player;

  for (let x = 0; x < vpWidth; x++) {
    let {
      Hit: hit,
      Top: top,
      Bottom: bottom,
      Side: side,
      // TexId: texId,
      // MipLvl: mipLvl,
      TexX: texX,
      TexY: texY,
      TexStepY: texStepY,
      Distance: wallDistance,
      FloorWallX: floorWallX,
      FloorWallY: floorWallY,
      Mipmap: mipmap,
      Height: projHeight,
      ClipTop: clipTop,
    } = wallSlices[x];

    const colPtr = startFramePtr + x;
    let framePtr = colPtr;
    let frameLimitPtr = frameRowPtrs[top] + x;

    // render ceil

    // for (let y = 0; y < top; y++) {
    for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      frameBuf32[framePtr] = CEIL_COLOR;
    }
    // assert(framePtr === colPtr + top * frameStride);

    // const wallSliceHeight = bottom - top + 1;
    // frameLimitPtr = framePtr + wallSliceHeight * frameStride;
    // assert(frameLimitPtr === frameRowPtrs[bottom + 1] + x);
    frameLimitPtr = frameRowPtrs[bottom + 1] + x;

    if (hit) {
      const {
        Buf32: mipPixels,
        // Width: texWidth,
        // Height: texHeight,
        Lg2Pitch: lg2Pitch,
      } = mipmap;

      // mipmap is rotated 90ccw
      // const mipStride = 1 << pitchLg2;
      const mipRowOffs = texX << lg2Pitch;

      // // wall alg1: bres
      // // const wallSliceHeight = bottom - top + 1;
      // // let numPixels = wallSliceHeight;
      // const frac = texWidth;
      // let counter = -projHeight + clipTop * frac;
      // let colIdx = mipRowOffs;
      // let color = mipPixels[colIdx];
      // // while (numPixels--) {
      // for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      //   while (counter >= 0) {
      //     counter -= projHeight;
      //     colIdx++;
      //     color = mipPixels[colIdx];
      //   }
      //   frameBuf32[framePtr] = color;
      //   counter += frac;
      // }

      // wall alg2: dda vers 1
      // for (let y = top; y <= bottom; y++) {
      // for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      //   const texColOffs = texY | 0;
      //   const color = mipPixels[mipRowOffs + texColOffs];
      //   // color = frameColorRGBAWasm.lightColorABGR(color, 255);
      //   // frameColorRGBAWasm.lightPixel(frameBuf32, dstPtr, 120);
      //   frameBuf32[framePtr] = color;
      //   texY += texStepY;
      // }

      // // wall alg2 dda vers 2
      let offs = mipRowOffs + texY;
      for (; framePtr < frameLimitPtr; framePtr += frameStride) {
        const color = mipPixels[offs | 0];
        frameBuf32[framePtr] = color;
        offs += texStepY;
      }

      // wall alg2 dda vers fixed
      // const FIX = 16;
      // let offs_fix = ((mipRowOffs + texY) * (1 << FIX)) | 0;
      // let texStepY_fix = (texStepY * (1 << FIX)) | 0;
      // for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      //   const color = mipPixels[offs_fix >> FIX];
      //   frameBuf32[framePtr] = color;
      //   offs_fix += texStepY_fix;
      // }

      // const offsets = texOffsetsArrays[projHeight];
      // // assert(offsets !== undefined);
      // for (let offIdx = 0; framePtr < frameLimitPtr; framePtr += frameStride) {
      //   frameBuf32[framePtr] = mipPixels[offsets[offIdx++]];
      // }

      // // wall alg3: fixed
      // const FIX = 16;
      // let texStepY_fix = (texStepY * (1 << FIX)) | 0;
      // let texY_fix = ((texY) * (1 << FIX)) | 0;
      // for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      //   const texColOffs = texY_fix >> FIX;
      //   const color = mipPixels[mipRowOffs + texColOffs];
      //   frameBuf32[framePtr] = color;
      //   texY_fix += texStepY_fix;
      // }

      // // wall alg4: dda when min, bres when mag
      // if (projHeight <= texWidth) {
      //   for (let y = top; y <= bottom; y++) {
      //     const texColOffs = texY | 0;
      //     let color = mipPixels[mipRowOffs + texColOffs];
      //     // const color = mipmap.Buf32[texY * texWidth + texX];
      //     // color = frameColorRGBAWasm.lightColorABGR(color, 255);
      //     frameBuf32[framePtr] = color;
      //     // frameColorRGBAWasm.lightPixel(frameBuf32, dstPtr, 120);
      //     texY += texStepY;
      //     framePtr += frameStride;
      //   }
      // } else {
      //   const frac = texWidth;
      //   let counter = -projHeight + clipTop * frac;
      //   let colIdx = mipRowOffs;
      //   let color = mipPixels[colIdx];
      //   for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      //     while (counter >= 0) {
      //       counter -= projHeight;
      //       colIdx++;
      //       color = mipPixels[colIdx];
      //     }
      //     frameBuf32[framePtr] = color;
      //     counter += frac;
      //   }
      //   // // prev version:
      //   // // const frac = texWidth;
      //   // // let counter = (clipTop * frac) % projHeight;
      //   // // let colIdx = mipRowOffs + (texY | 0);
      //   // // let color = mipPixels[colIdx];
      //   // // while (numPixels--) {
      //   // //   frameBuf32[framePtr] = color;
      //   // //   counter += frac;
      //   // //   while (counter >= projHeight) {
      //   // //     counter -= projHeight;
      //   // //     colIdx++;
      //   // //     color = mipPixels[colIdx];
      //   // //   }
      //   // //   framePtr += frameStride;
      //   // // }
      // }

      // // // wall alg5
      // let offsets = texOffsetsArrays[projHeight];
      // if (!offsets) {
      //   offsets = new Uint32Array(projHeight);
      //   let yOffs = texY;
      //   for (let i = 0; i !== projHeight; ++i) {
      //     offsets[i] = yOffs | 0;
      //     yOffs += texStepY;
      //   }
      //   texOffsetsArrays[projHeight] = offsets;
      // }
      // for (
      //   let offIdx = 0;
      //   framePtr < frameLimitPtr;
      //   framePtr += frameStride, offIdx++
      // ) {
      //   frameBuf32[framePtr] = mipPixels[mipRowOffs + offsets[offIdx]];
      // }
    } else {
      // no hit untextured wall
      const color = side === 0 ? 0xff0000ee : 0xff0000aa;
      // for (let y = top; y <= bottom; y++) {
      for (; framePtr < frameLimitPtr; framePtr += frameStride) {
        frameBuf32[framePtr] = color;
      }
    }

    // assert(framePtr === colPtr + (bottom + 1) * frameStride);

    if (!isFloorTextured) {
      for (let y = bottom + 1; y < vpHeight; y++) {
        frameBuf32[framePtr] = FLOOR_COLOR;
        framePtr += frameStride;
      }
    } else {
      let prevFloorMapIdx = null;
      let floorMip;

      for (let y = bottom + 1; y < vpHeight; y++, framePtr += frameStride) {
        // y in [bottom + 1, height), dist in [1, +inf), dist == 1 when y == height
        const dist = posZ / (y - projYCenter);
        let weight = dist / wallDistance;
        // assert(weight >= 0);
        // assert(weight <= 1);
        let floorX = weight * floorWallX + (1 - weight) * posX;
        let floorY = weight * floorWallY + (1 - weight) * posY;
        const floorXidx = floorX | 0;
        const floorYidx = floorY | 0;
        const floorMapIdx = floorYidx * mapWidth + floorXidx;
        const sameFloorMapIdx = floorMapIdx === prevFloorMapIdx;
        if (
          sameFloorMapIdx ||
          (floorMapIdx >= 0 && floorMapIdx < floorMap.length)
        ) {
          if (!sameFloorMapIdx) {
            const floorTexIdx = floorMap[floorMapIdx];
            floorMip = textures[floorTexIdx].getMipmap(0).Image;
            prevFloorMapIdx = floorMapIdx;
          }
          const mip = floorMip!;
          const u = floorX - floorXidx;
          const v = floorY - floorYidx;
          // assert(floorX >= 0 && floorX < 1);
          // assert(floorY >= 0 && floorY < 1);
          const floorMipX = u * mip.Width;
          const floorMipY = v * mip.Height;
          const mipOffs = (floorMipX << mip.Lg2Pitch) | floorMipY;
          // assert(mipOffs >= 0 && mipOffs < floorMip.Buf32.length);
          const color = mip.Buf32[mipOffs];
          frameBuf32[framePtr] = color;
        }
      }
    }
    // assert(framePtr === colPtr + vpHeight * frameStride);
  }

  // // render horizontal lines for minWallTop and maxWallBottom
  // const minTopRowPtr = screenPtr + minWallTop * frameStride;
  // const maxBottomRowPtr = screenPtr + maxWallBottom * frameStride;
  // for (let i = colStart; i < colEnd; i++) {
  //   frameBuf32[minTopRowPtr + i] = 0xff0000ff;
  //   frameBuf32[maxBottomRowPtr + i] = 0xff0000ff;
  // }

  // ...
  // const colPtr = renderParams.screenPtr;
  // let scrPtr = colPtr + wallTop * stride;

  // // textured wall
  // for (let y = wallTop; y < wallBottom; y++) {
  //   const texY = texPosY | 0; // + 0.5 | 0;
  //   texPosY += texStepY;
  //   const color = texture.Buf32[texY * texWidth + texX];
  //   frameBuf32[scrPtr] = color;
  //   scrPtr += stride;
  // }

  // // solid color
  // for (let y = wallTop; y < wallBottom; y++) {
  //   frameBuf32[scrPtr] = 0xff0000ff;
  //   scrPtr += stride;
  // }
}

// const wallSliceHeight = bottom - top + 1;
// frameLimitPtr = framePtr + wallSliceHeight * frameStride;
// assert(frameLimitPtr === frameRowPtrs[bottom + 1] + x);

// sprite processing by rows, not used
// for (let y = startY; y <= endY; y++) {
//   let framePtr = frameRowPtrs[y] + startX;
//   let frameLimitPtr = frameRowPtrs[y] + endX;
//
//   for (; framePtr <= frameLimitPtr; framePtr++) {
//     const color = mipPixels[offs | 0];
//     if (color !== transpColor) {
//       frameBuf32[framePtr] = color;
//     }
//     offs += texStepX;
//   }
//   offs += texStepY;
// }

// sprite inner loop before using precald y offsets
// let texYOffs = texY;
// let framePtr = startYPtr;
// for (let y = startY; y <= endY; y++) {
//   const color = mipPixels[mipRowOffs + (texYOffs | 0)];
//   if (color !== transpColor) {
//     frameBuf32[framePtr] = color;
//   }
//   texYOffs += texStepY;
//   framePtr += frameStride;
// }

private renderWallsFloorsVert2() {
  const {
    startFramePtr,
    frameBuf32,
    frameStride,
    frameRowPtrs,
    spansFloorLX,
    spansFloorLY,
    spansStepX,
    spansStepY,
    raycaster,
    isFloorTextured: texturedFloor,
    textures,
  } = this;

  const {
    FloorMap: floorMap,
    WallSlices: wallSlices,
    MapWidth: mapWidth,
    ProjYCenter: projYCenter,
    MinWallBottom: minWallBottom,
  } = raycaster;

  const {
    // StartX: vpStartX,
    // StartY: vpStartY,
    Width: vpWidth,
    Height: vpHeight,
  } = raycaster.Viewport;

  const {
    DirX: dirX,
    DirY: dirY,
    PosX: posX,
    PosY: posY,
    PosZ: posZ,
    PlaneX: planeX,
    PlaneY: planeY,
  } = raycaster.Player;

  const rayDirLeftX = dirX - planeX;
  const rayDirLeftY = dirY - planeY;
  const rayDirRightX = dirX + planeX;
  const rayDirRightY = dirY + planeY;
  const invWidth = 1 / vpWidth;
  const rayStepX = (rayDirRightX - rayDirLeftX) * invWidth;
  const rayStepY = (rayDirRightY - rayDirLeftY) * invWidth;

  for (let y = minWallBottom + 1; y < vpHeight; ++y) {
    const yd = y - projYCenter;
    const sDist = posZ / yd;
    spansFloorLX[y] = posX + sDist * rayDirLeftX;
    spansFloorLY[y] = posY + sDist * rayDirLeftY;
    spansStepX[y] = sDist * rayStepX;
    spansStepY[y] = sDist * rayStepY;
  }

  for (let x = 0; x < vpWidth; x++) {
    let {
      Hit: hit,
      Top: top,
      Bottom: bottom,
      Side: side,
      // TexId: texId,
      // MipLvl: mipLvl,
      TexX: texX,
      TexY: texY,
      TexStepY: texStepY,
      // Distance: wallDistance,
      // FloorWallX: floorWallX,
      // FloorWallY: floorWallY,
      Mipmap: mipmap,
    } = wallSlices[x];

    const colPtr = startFramePtr + x;
    let framePtr = colPtr;
    let frameLimitPtr = frameRowPtrs[top] + x;

    // render ceil
    // for (let y = 0; y < top; y++) {
    for (; framePtr < frameLimitPtr; framePtr += frameStride) {
      frameBuf32[framePtr] = CEIL_COLOR;
    }
    // assert(framePtr === colPtr + top * frameStride);
    // assert(framePtr === frameLimitPtr);

    frameLimitPtr = frameRowPtrs[bottom + 1] + x;

    if (hit) {
      const {
        Buf32: mipPixels,
        // Width: texWidth,
        // Height: texHeight,
        Lg2Pitch: lg2Pitch,
      } = mipmap;

      const mipRowOffs = texX << lg2Pitch;
      let offs = mipRowOffs + texY;
      // // wall alg2: dda
      for (; framePtr < frameLimitPtr; framePtr += frameStride) {
        const color = mipPixels[offs | 0];
        frameBuf32[framePtr] = color;
        offs += texStepY;
      }
    } else {
      // no hit untextured wall
      const color = side === 0 ? 0xff0000ee : 0xff0000aa;
      // for (let y = top; y <= bottom; y++) {
      for (; framePtr < frameLimitPtr; framePtr += frameStride) {
        frameBuf32[framePtr] = color;
      }
    }
    // assert(framePtr === colPtr + (bottom + 1) * frameStride);

    if (!texturedFloor) {
      for (let y = bottom + 1; y < vpHeight; y++) {
        frameBuf32[framePtr] = FLOOR_COLOR;
        framePtr += frameStride;
      }
    } else {
      let floorMip;
      let prevFloorMapIdx = null;

      for (let y = bottom + 1; y < vpHeight; y++, framePtr += frameStride) {
        const floorX = spansFloorLX[y] + x * spansStepX[y];
        const floorY = spansFloorLY[y] + x * spansStepY[y];
        const floorXidx = floorX | 0;
        const floorYidx = floorY | 0;
        const floorMapIdx = floorYidx * mapWidth + floorXidx;
        const sameFloorMapIdx = floorMapIdx === prevFloorMapIdx;
        if (
          sameFloorMapIdx ||
          (floorMapIdx >= 0 && floorMapIdx < floorMap.length)
        ) {
          if (!sameFloorMapIdx) {
            const floorTexIdx = floorMap[floorMapIdx];
            floorMip = textures[floorTexIdx].getMipmap(0).Image;
            prevFloorMapIdx = floorMapIdx;
          }
          const mip = floorMip!;
          const u = floorX - floorXidx;
          const v = floorY - floorYidx;
          // assert(u >= 0 && u < 1);
          // assert(v >= 0 && v < 1);
          const floorMipX = u * mip.Width;
          const floorMipY = v * mip.Height;
          const mipOffs = (floorMipX << mip.Lg2Pitch) | floorMipY;
          // assert(mipOffs >= 0 && mipOffs < floorMip.Buf32.length);
          const color = mip.Buf32[mipOffs];
          frameBuf32[framePtr] = color;
        }
      }
    }
    // assert(framePtr === colPtr + vpHeight * frameStride);
  }
}

private renderViewFullHorz() {
  const {
    frameBuf32,
    startFramePtr,
    frameStride,
    spansStepX,
    spansStepY,
    spansFloorLX,
    spansFloorLY,
    frameRowPtrs,
    raycaster,
  } = this;

  const {
    FloorMap: floorMap,
    WallSlices: wallSlices,
    // MapWidth: mapWidth,
    ProjYCenter: projYCenter,
    MinWallTop: minWallTop,
    MaxWallTop: maxWallTop,
    MinWallBottom: minWallBottom,
    MaxWallBottom: maxWallBottom,
  } = raycaster;

  const {
    // StartX: vpStartX,
    // StartY: vpStartY,
    Width: vpWidth,
    Height: vpHeight,
  } = raycaster.Viewport;

  const {
    DirX: dirX,
    DirY: dirY,
    PosX: posX,
    PosY: posY,
    PosZ: posZ,
    PlaneX: planeX,
    PlaneY: planeY,
  } = raycaster.Player;

  const rayDirLeftX = dirX - planeX;
  const rayDirLeftY = dirY - planeY;
  const rayDirRightX = dirX + planeX;
  const rayDirRightY = dirY + planeY;
  const invWidth = 1 / vpWidth;
  const rayStepX = (rayDirRightX - rayDirLeftX) * invWidth;
  const rayStepY = (rayDirRightY - rayDirLeftY) * invWidth;

  for (let y = minWallBottom + 1; y < vpHeight; ++y) {
    const yd = y - projYCenter;
    const sDist = posZ / yd;
    spansFloorLX[y] = posX + sDist * rayDirLeftX;
    spansFloorLY[y] = posY + sDist * rayDirLeftY;
    spansStepX[y] = sDist * rayStepX;
    spansStepY[y] = sDist * rayStepY;
  }

  // render horz ceiling above walls
  for (let y = 0; y < minWallTop; y++) {
    this.renderCeilSpan(y, 0, vpWidth - 1);
  }

  let rowFramePtr = startFramePtr + frameRowPtrs[minWallTop];

  // render walls top half
  for (let y = minWallTop; y < maxWallTop; ++y, rowFramePtr += frameStride) {
    let framePtr = rowFramePtr;
    for (let x = 0; x < vpWidth; ++x, ++framePtr) {
      const wallSlice = wallSlices[x];
      if (y < wallSlice.Top) {
        frameBuf32[framePtr] = CEIL_COLOR;
      } else {
        const mipmap = wallSlices[x].Mipmap;
        const texOffs = (wallSlice.TexX << mipmap.Lg2Pitch) | wallSlice.TexY;
        frameBuf32[framePtr] = mipmap.Buf32[texOffs];
        wallSlice.TexY += wallSlice.TexStepY;
      }
    }
  }

  // render walls central part
  for (
    let y = maxWallTop;
    y <= minWallBottom;
    ++y, rowFramePtr += frameStride
  ) {
    let framePtr = rowFramePtr;
    for (let x = 0; x < vpWidth; ++x) {
      const wallSlice = wallSlices[x];
      const mipmap = wallSlices[x].Mipmap;
      const texOffs = (wallSlice.TexX << mipmap.Lg2Pitch) | wallSlice.TexY;
      frameBuf32[framePtr++] = mipmap.Buf32[texOffs];
      wallSlice.TexY += wallSlice.TexStepY;
    }
  }

  // render walls bottom half
  for (
    let y = minWallBottom + 1;
    y <= maxWallBottom;
    ++y, rowFramePtr += frameStride
  ) {
    let x1span = 0;
    let x2span = -1;
    let framePtr = rowFramePtr;
    for (let x = 0; x < vpWidth; ++x, ++framePtr) {
      const wallSlice = wallSlices[x];
      if (y <= wallSlice.Bottom) {
        // render left floor span
        this.renderFloorSpan(y, x1span, x2span);
        // render wall pixel
        const mipmap = wallSlices[x].Mipmap;
        const texOffs = (wallSlice.TexX << mipmap.Lg2Pitch) | wallSlice.TexY;
        frameBuf32[framePtr] = mipmap.Buf32[texOffs];
        wallSlice.TexY += wallSlice.TexStepY;
        x1span = x + 1;
        x2span = x;
      } else {
        x2span++;
      }
    }
    this.renderFloorSpan(y, x1span, x2span);
  }

  // render floor spans below maxWallBottom
  for (let y = maxWallBottom + 1; y < vpHeight; y++) {
    this.renderFloorSpan(y, 0, vpWidth - 1);
  }
}

for (
  let x = startX;
  x <= endX;
  x++, startYPtr++, endYPtr++, texX += texStepX
) {
  if (
    !sliceFullyTranspMap[texX | 0] &&
    distance <= wallZBuffer[x] &&
    transpSlices[x] === WASM_NULL_PTR
  ) {
    const mipRowOffs = texX << lg2Pitch;
    let framePtr = startYPtr;
    for (let y = startY; y <= endY; y++, framePtr += frameStride) {
      const color = mipPixels[mipRowOffs + texYOffsets[y]];
      if (color !== transpColor) {
        frameBuf32[framePtr] = color;
      }
    }
  }
}

for (
  let x = startX;
  x <= endX;
  x++, startYPtr++, texX += texStepX
) {
  if (
    !sliceFullyTranspMap[texX | 0] &&
    distance <= wallZBuffer[x] &&
    transpSlices[x] === WASM_NULL_PTR
  ) {
    const mipRowOffs = texX << lg2Pitch;
    let framePtr = startYPtr;
    let occPtr = occlusionBufRowPtrs[startY] + x;
    for (
      let y = startY;
      y <= endY;
      y++, framePtr += frameStride, occPtr += frameStride
    ) {
      if (!occlusionBuf8[occPtr]) {
        const color = mipPixels[mipRowOffs + texYOffsets[y]];
        if (color !== transpColor) {
          frameBuf32[framePtr] = color;
          occlusionBuf8[occPtr] = 1;
        }
      }
    }
  }
}
